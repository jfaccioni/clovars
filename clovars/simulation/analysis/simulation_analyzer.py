from __future__ import annotations

from typing import Any, TYPE_CHECKING, Generator

import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.stats import norm

from clovars.utils import PathCreatorMixin, QuietPrinterMixin

if TYPE_CHECKING:
    from clovars.bio import Treatment
    from clovars.scientific import Numeric


class SimulationAnalyzer(QuietPrinterMixin, PathCreatorMixin):
    """Class that handles analysis of data generated by a Simulation run."""
    default_output_folder = '.'
    default_treatments_bootstrap_n = 100
    default_dynafit_start_day = 1.0
    default_dynafit_end_day = 2.0
    default_cs_bins = 10
    default_cs_group_filter = 3
    default_dynafit_bootstrap_n = 100
    default_dists_file_name = 'dists'
    default_dists_file_extension = '.png'
    default_gaussians_file_name = 'gaussians'
    default_gaussians_file_extension = '.png'

    def __init__(
            self,
            cell_data: pd.DataFrame,
            colony_data: pd.DataFrame,
            delta: int,
            treatment_data: dict[tuple[str, int], Treatment],
            verbose: bool = False,
            output_folder: str = default_output_folder,
    ) -> None:
        """Initializes a SimulationViewer instance."""
        self.cell_data = cell_data
        self.colony_data = colony_data
        self.delta = delta
        self.treatments = treatment_data
        super().__init__(verbose=verbose, folder=output_folder)

    @property
    def last_frame(self) -> int:
        """Returns the number of the last frame in the Simulation."""
        return int(self.cell_data['simulation_seconds'].max() / self.delta)

    def analyse(
            self,
            settings: dict[str, Any],
    ) -> None:
        """Analyses the view of the Simulation."""
        if settings.get('compare_treatments', False) is True:
            self.quiet_print('Comparing treatments for statistical significance...')
            treatments_bootstrap_n = settings.get('treatments_bootstrap_n', self.default_treatments_bootstrap_n)
            self.compare_treatments(treatments_bootstrap_n=treatments_bootstrap_n)
        if settings.get('plot_dynafit', False) is True:
            self.quiet_print('Plotting cross-colony variance as a function of colony size...')
            self.plot_dynafit(
                dynafit_start_day=settings.get('dynafit_start_day', self.default_dynafit_start_day),
                dynafit_end_day=settings.get('dynafit_end_day', self.default_dynafit_end_day),
                cs_group_filter=settings.get('cs_group_filter', self.default_cs_group_filter),
                cs_merge=settings.get('cs_merge', True),
                cs_bins=settings.get('cs_bins', self.default_cs_bins),
                dynafit_bootstrap_n=settings.get('dynafit_bootstrap_n', self.default_dynafit_bootstrap_n),
                use_log_colony_size=settings.get('use_log_colony_size', True),

            )
        join_treatments = settings.get('join_treatments', True)
        if settings.get('show_cell_fate_distributions', False) is True:
            self.quiet_print('Displaying Cell time-to-fate distributions...')
            self.show_cell_fate_distributions(join_treatments=join_treatments)
        if settings.get('render_cell_fate_distributions', False) is True:
            self.quiet_print('Rendering Cell time-to-fate distributions...')
            self.render_cell_fate_distributions(
                dists_file_name=settings.get('distributions_file_name', self.default_dists_file_name),
                dists_file_extension=settings.get('distributions_file_extension', self.default_dists_file_extension),
                join_treatments=join_treatments,
            )
        if settings.get('show_cell_fitness_distributions', False) is True:
            self.quiet_print('Displaying Cell fitness distributions...')
            self.show_cell_fitness_distributions()
        if settings.get('show_colony_division_times_cv', False) is True:
            self.quiet_print('Showing CV of Colony division times...')
            self.show_colony_division_times_cv()
        if settings.get('write_video_colony_signal_vs_size_over_time', False) is True:
            self.quiet_print('Rendering video of Colony Signal vs Size over time...')
            self.write_video_colony_signal_vs_size_over_time()
        if settings.get('write_video_colony_fitness_over_time', False) is True:
            self.quiet_print('Rendering video of Colony fitness over time...')
            self.write_video_colony_fitness_over_time()

    def compare_treatments(
            self,
            treatments_bootstrap_n: int = 100,
    ) -> None:
        """Compares trees across treatments to check whether they are significantly different or not."""
        data = self.get_distribution_data()
        data_dict = {}
        for treatment_name, treatment_data in data.groupby('treatment'):
            data_dict[treatment_name] = self.get_data_stats(
                division_values=treatment_data.loc[treatment_data['event'] == 'division'].head()['hours'].values,
                death_values=treatment_data.loc[treatment_data['event'] == 'death'].head()['hours'].values,
                n_events=len(treatment_data),
            )
        bootstrap_dict = {}
        self.quiet_print('Bootstrapping data...')
        for group_label, group_data in data_dict.items():
            bootstrap_dict[group_label] = self.bootstrap_data(
                division_values=group_data['division_values'],
                death_values=group_data['death_values'],
                n_events=group_data['n_events'],
                treatments_bootstrap_n=treatments_bootstrap_n,
            )
        fig, axes = plt.subplots(nrows=2)
        colors = ['blue', 'orange']
        styles = ['--', ':']
        for color, ax, (bootstrap_label, bootstrap_values) in zip(colors, axes, bootstrap_dict.items()):
            bootstrap_finite_values = bootstrap_values[np.isfinite(bootstrap_values)]
            title = f'{bootstrap_label} $\Lambda$ bootstrap distribution, repeats = {treatments_bootstrap_n}'  # noqa
            ax.set_title(title)
            sns.histplot(ax=ax, x=bootstrap_finite_values, color=color, kde=True)
            boot_label = f'Distribution 99% quantile'
            ax.axvline(np.nanquantile(bootstrap_finite_values, 0.99), label=boot_label, color=color, linestyle='-')
        for color, style, ax, (group0_label, group0_data) in zip(colors, styles, axes, data_dict.items()):
            for group1_label, group1_data in data_dict.items():
                if group0_label != group1_label:
                    self.quiet_print(f'testing Groups: {group1_label} vs. {group0_label}')
                    lambda_value = self.calculate_log_likelihood_ratio(
                        division_values=group0_data['division_values'],
                        death_values=group0_data['death_values'],
                        theta_0=group0_data['theta'],
                        theta_1=group1_data['theta'],
                        n_events_0=group0_data['n_events'],
                        n_events_1=group1_data['n_events'],
                    )
                    label = f'$\Lambda$($D$_{group0_label}, $\Theta$_{group0_label}, $\Theta$_{group1_label})'  # noqa
                    ax.axvline(lambda_value, label=label, color=color, linestyle=style, alpha=0.7)
        for ax in axes:
            ax.set_xlabel('$\Lambda$ value')  # noqa
            ax.legend()
        plt.show()

    def get_data_stats(
            self,
            division_values: np.array,
            death_values: np.array,
            n_events: int,
    ) -> dict[str, Numeric]:
        """Calculates the stats for a given data."""
        return {
            'n_events': n_events,
            'division_values': division_values,
            'division_n_events': len(division_values),
            'death_values': death_values,
            'death_n_events': len(death_values),
            'theta': self.calculate_theta(
                division_values=division_values,
                death_values=death_values,
                n_events=n_events,
            ),
        }

    def calculate_theta(
            self,
            division_values: np.array,
            death_values: np.array,
            n_events: int,
    ) -> np.array:
        """Returns the theta (tree parameter vector) from the input data."""
        division_stats = self.get_stats(event_values=division_values, n_events=n_events)
        death_stats = self.get_stats(event_values=death_values, n_events=n_events)
        return np.array([*division_stats, *death_stats])

    def bootstrap_data(
            self,
            division_values: np.array,
            death_values: np.array,
            n_events: int,
            treatments_bootstrap_n: int,
    ) -> np.array:
        """Returns the probability, mean and std of the values."""
        lambdas = []
        for boot_repeat in range(treatments_bootstrap_n):
            self.quiet_print(f'Treatment comparison bootstrap {boot_repeat + 1}/{treatments_bootstrap_n}')
            division_values_0 = np.random.choice(division_values, len(division_values), replace=True)
            death_values_0 = np.random.choice(death_values, len(death_values), replace=True)
            theta_0 = self.calculate_theta(
                division_values=division_values_0,
                death_values=death_values_0,
                n_events=n_events,
            )
            division_values_1 = np.random.choice(division_values, len(division_values), replace=True)
            death_values_1 = np.random.choice(death_values, len(death_values), replace=True)
            theta_1 = self.calculate_theta(
                division_values=division_values_1,
                death_values=death_values_1,
                n_events=n_events,
            )
            lambda_value = self.calculate_log_likelihood_ratio(
                division_values=division_values_0,
                death_values=death_values_0,
                theta_0=theta_0,
                theta_1=theta_1,
                n_events_0=n_events,
                n_events_1=n_events,
            )
            lambdas.append(lambda_value)
        return np.array(lambdas)

    @staticmethod
    def get_stats(
            event_values: np.array,
            n_events: int,
    ) -> tuple[float, float, float]:
        """Returns the probability, mean and std of the values."""
        if event_values.size == 0:  # event_values is an empty numpy array
            return 0.0, np.nan, np.nan
        return len(event_values) / n_events, event_values.mean(), event_values.std()

    def calculate_log_likelihood_ratio(
            self,
            division_values: np.array,
            death_values: np.array,
            theta_0: np.array,
            theta_1: np.array,
            n_events_0: int,
            n_events_1: int,
    ) -> float:
        """Returns the likelihood ratio for the given thetas and input data."""
        upper = self.calculate_log_likelihood(
            theta=theta_1,
            division_values=division_values,
            death_values=death_values,
            n_events=n_events_1,
        )
        lower = self.calculate_log_likelihood(
            theta=theta_0,
            division_values=division_values,
            death_values=death_values,
            n_events=n_events_0,
        )
        return upper / lower

    @staticmethod
    def calculate_log_likelihood(
            division_values: np.array,
            death_values: np.array,
            theta: np.array,
            n_events: int,
    ) -> float:
        """Returns the likelihood function for the given theta and input data."""
        # DIVISION
        p_div = theta[0]
        n_div = len(division_values)
        div_probas = np.log(norm(loc=theta[1], scale=theta[2]).pdf(division_values)).sum()
        # DEATH
        p_death = theta[3]
        n_death = len(death_values)
        death_probas = np.log(norm(loc=theta[4], scale=theta[5]).pdf(death_values)).sum()
        # MIGRATION
        p_mig = 1 - (p_div + p_death)
        n_mig = n_events - (n_div + n_death)
        # FIX BAD _probas FOR LOG
        if np.isnan([theta[1], theta[2]]).any():
            div_probas = 0
        if np.isnan([theta[4], theta[5]]).any():
            death_probas = 0
        # FIX BAD p_ FOR LOG
        if p_div == 0:
            p_div = 1
        if p_death == 0:
            p_death = 1
        if p_mig == 0:
            p_mig = 1
        # CALCULATE AND RETURN
        return n_div * np.log(p_div) + n_death * np.log(p_death) + n_mig * np.log(p_mig) + div_probas + death_probas

    def plot_dynafit(
            self,
            dynafit_start_day: float,
            dynafit_end_day: float,
            cs_group_filter: int | None = 3,
            cs_merge: bool = False,
            cs_bins: int = 10,
            dynafit_bootstrap_n: int = 100,
            use_log_colony_size: bool = True,
    ) -> None:
        """Plots the variance of the feature name across colonies as a function of colony size."""
        # Filters for colonies in range
        days = self.colony_data['simulation_seconds'] / (60 * 60 * 24)
        filtered_colony_data = self.colony_data.loc[days.between(dynafit_start_day, dynafit_end_day)]

        # Gets GR and CS dataset
        def get_daily_growth_rate(df: pd.DataFrame) -> float:
            """Returns the daily growth rate for the input pandas DataFrame."""
            seconds_to_days = 1 / (60 * 60 * 24)
            first, last = df.iloc[0], df.iloc[-1]
            upper = np.log2(last['size']) - np.log2(first['size'])
            lower = (last['simulation_seconds'] * seconds_to_days) - (first['simulation_seconds'] * seconds_to_days)
            return upper / lower
        dynafit_data = pd.DataFrame({
            'growth_rate': filtered_colony_data.groupby('name').apply(get_daily_growth_rate),
            'initial_colony_size': filtered_colony_data.groupby('name')['size'].first(),
        })
        # Avoids negative GRs
        dynafit_data.loc[dynafit_data['growth_rate'] <= 0, 'growth_rate'] = 0.5
        # Filters colonies with small number of members
        if cs_group_filter is not None:
            cs_groups = dynafit_data['initial_colony_size'].groupby(dynafit_data['initial_colony_size'])
            colony_size_filter = cs_groups.transform('size') > cs_group_filter
            dynafit_data = dynafit_data[colony_size_filter]
        # Calculates CS-wise growth rates from data
        dynafit_data['CS_group'] = pd.qcut(dynafit_data['initial_colony_size'], cs_bins, duplicates='drop')
        # Defines whether to merge colonies of different sizes or not
        if cs_merge is True:
            dynafit_data['CS'] = dynafit_data.groupby('CS_group')['initial_colony_size'].transform(np.mean)
        else:
            dynafit_data['CS'] = dynafit_data['initial_colony_size']
        if use_log_colony_size is True:
            dynafit_data['log2_CS'] = np.log2(dynafit_data['CS'])
        else:
            dynafit_data['log2_CS'] = dynafit_data['CS']
        dynafit_data['log2_GR'] = np.log2(dynafit_data['growth_rate'])
        # Gets figure and axes
        fig, (ax1, ax2) = plt.subplots(nrows=2)
        # Plots CS-wise growth rates from data
        sns.violinplot(data=dynafit_data, ax=ax1, x='log2_CS', y='growth_rate', inner=None, color=".8")
        sns.stripplot(data=dynafit_data, ax=ax1, x='log2_CS', y='growth_rate')
        # Estimates DynaFit CVP from data
        dfs = []
        for boot_repeat in range(dynafit_bootstrap_n):
            self.quiet_print(f'Dynafit Bootstrap {boot_repeat + 1}/{dynafit_bootstrap_n}')
            sample = dynafit_data.groupby('log2_CS').sample(frac=1.0, replace=True)
            grouped_sample = sample.groupby('log2_CS')
            boot = pd.DataFrame({
                'boot_repeat': boot_repeat,
                'log2_var_GR': np.log2(grouped_sample['growth_rate'].var()),
                'log2_mean_CS': np.log2(grouped_sample['initial_colony_size'].mean()),
            })
            dfs.append(boot.reset_index())
        dynafit_bootstrap_data = pd.concat(dfs, ignore_index=True)
        dynafit_bootstrap_data = dynafit_bootstrap_data[np.isfinite(dynafit_bootstrap_data).all(1)]  # Drop nan / inf
        # Plots DynaFit CVP from data
        mean_xs = range(len(dynafit_bootstrap_data['log2_CS'].unique()))
        mean_ys = dynafit_bootstrap_data.groupby('log2_CS')['log2_var_GR'].mean()
        sns.violinplot(data=dynafit_bootstrap_data, ax=ax2, x='log2_CS', y='log2_var_GR', inner=None, color=".8")
        sns.stripplot(data=dynafit_bootstrap_data, ax=ax2, x='log2_CS', y='log2_var_GR')
        ax2.scatter(mean_xs, mean_ys, s=1000, marker="*", color=".4", edgecolor="gold", zorder=999)
        # Formats plots
        fig.suptitle(f'Dynafit Analysis, days {dynafit_start_day} ~ {dynafit_end_day}')
        ax1.set_title(f'Colony GR')
        ax2.set_title(f'Bootstrapped Colony GR variance (n={dynafit_bootstrap_n})')
        ax1.set_xticklabels(map(lambda label: round(float(label.get_text()), 3), ax1.get_xticklabels()))
        ax2.set_xticklabels(map(lambda label: round(float(label.get_text()), 3), ax2.get_xticklabels()))
        if use_log_colony_size is False:
            ax1.set_xlabel('CS group')
            ax2.set_xlabel('CS group')
        fig.tight_layout()
        plt.show()

    def show_cell_fate_distributions(
            self,
            join_treatments: bool,
    ) -> None:
        """Shows the distributions on a matplotlib plot."""
        for figure, _ in self.yield_distributions(join_treatments=join_treatments):
            plt.subplots_adjust(top=0.921, bottom=0.067, left=0.051, right=0.991, hspace=0.2, wspace=0.166)
            plt.show()

    def render_cell_fate_distributions(
            self,
            dists_file_name: str,
            dists_file_extension: str,
            join_treatments: bool,
    ) -> None:
        """Shows the distributions on a matplotlib plot."""
        for figure, label in self.yield_distributions(join_treatments=join_treatments):
            plt.subplots_adjust(top=0.921, bottom=0.067, left=0.051, right=0.991, hspace=0.2, wspace=0.166)
            figure_path = self.path / f'{dists_file_name}_{label}.{dists_file_extension}'
            plt.tight_layout()
            figure.savefig(figure_path, dpi=120)
            plt.close(figure)

    def yield_distributions(
            self,
            join_treatments: bool,
    ) -> Generator[tuple[plt.Figure, str], None, None]:
        """Sequentially yields distribution Figures from the Simulation view."""
        data = self.get_distribution_data()
        if join_treatments is True:
            data['treatment'] = 'All cells'
        for treatment_name, treatment_data in data.groupby('treatment'):
            yield from self.yield_treatment_distribution(
                treatment_name=treatment_name,  # noqa
                treatment_data=treatment_data,
            )

    @staticmethod
    def yield_treatment_distribution(
            treatment_name: str,
            treatment_data: pd.DataFrame,
    ) -> Generator[tuple[plt.Figure, str], None, None]:
        """Yields a figure with the treatment distribution."""
        fig, (upper_ax, middle_ax, lower_ax) = plt.subplots(ncols=3, figsize=(16, 9))
        sns.histplot(ax=upper_ax, data=treatment_data, x='hours', hue='event', kde=True, bins=50, stat='density')
        left_xlim, right_xlim = upper_ax.get_xlim()
        xs = np.linspace(left_xlim, right_xlim, 1000)
        for event_label, event_data in treatment_data.groupby('event'):
            probability = len(event_data) / len(treatment_data)
            mean, std = norm.fit(event_data['hours'])
            label = (
                f'{event_label}\n'
                f'$p$={round(probability, 2)}, '
                f'$\mu$={round(mean, 2)}, '
                f'$\sigma$={round(std, 2)}'
            )  # noqa
            ys = norm(loc=mean, scale=std).pdf(xs)
            sns.lineplot(ax=middle_ax, x=xs, y=ys, label=label)
            sns.lineplot(ax=lower_ax, x=xs, y=ys * probability, label=label)
        upper_ax.set_title('Simulation view')
        middle_ax.set_xlabel('hours')
        middle_ax.set_ylabel('density')
        middle_ax.set_title('Gaussian estimates (density function)')
        middle_ax.set_ylim(bottom=0.0)
        lower_ax.set_xlabel('hours')
        lower_ax.set_ylabel('probability')
        lower_ax.set_title('Gaussian estimates (overall probability)')
        lower_ax.set_ylim(bottom=0.0)
        fig.suptitle(treatment_name)
        yield fig, treatment_name

    def get_distribution_data(self) -> pd.DataFrame:
        """Returns a data of the Simulation distribution of division, death and migration times."""
        terminal_nodes = self.cell_data.groupby('name').last()
        data = pd.DataFrame({
            'event': terminal_nodes['fate_at_next_frame'],
            'hours': terminal_nodes['seconds_since_birth'] / (60 * 60),
            'frame': terminal_nodes['simulation_seconds'] / self.delta,
        }).sort_values(by='event')
        data['treatment'] = pd.cut(
            data['frame'],
            bins=[int(k[1]) for k in self.treatments.keys()] + [self.last_frame],
            labels=[treatment.name for treatment in self.treatments.values()],
            include_lowest=True,
            right=True,
        )
        return data

    def show_cell_fitness_distributions(self) -> None:
        """Displays the fitness distributions across all Cell branches."""
        death_dist = self.cell_data.groupby('name').first()['death_threshold'].values
        division_dist = self.cell_data.groupby('name').first()['division_threshold'].values
        fig, ax = plt.subplots()
        sns.histplot(death_dist, ax=ax, kde=True, color='red', label='Death threshold', bins=50)
        sns.histplot(division_dist, ax=ax, kde=True, color='green', label='Division threshold', bins=50)
        plt.xlim(0, 1)
        plt.show()

    def show_colony_division_times_cv(self) -> None:
        """Displays the CV of division times for each Colony."""
        # Get last cells in each branch
        last_cells = self.cell_data.groupby('name').last().reset_index()
        # Remove cells in last frame (they are at the branch end, but do not correspond to cells prior to division)
        last_cells = last_cells.loc[last_cells['simulation_seconds'] != self.cell_data['simulation_seconds'].max()]

        last_cells['hours_since_birth'] = last_cells['seconds_since_birth'] / (60 * 60)

        colony_generations = last_cells.groupby(['colony_name', 'generation'])
        colony_hours_mean = colony_generations['hours_since_birth'].mean().reset_index()
        colony_hours_var = colony_generations['hours_since_birth'].var().reset_index()
        colony_hours_cv = (
                colony_generations['hours_since_birth'].var() /
                colony_generations['hours_since_birth'].mean()
        ).reset_index().dropna()
        fig, (ax1, ax2, ax3) = plt.subplots(nrows=3, sharex='all')
        sns.violinplot(
            data=self.filter_invalid(colony_hours_mean),
            ax=ax1,
            x='generation',
            y='hours_since_birth',
            palette='rocket',
        )
        sns.stripplot(
            data=self.filter_invalid(colony_hours_mean),
            ax=ax1,
            x='generation',
            y='hours_since_birth',
            alpha=0.5,
            color='0.5',
        )
        sns.violinplot(
            data=self.filter_invalid(colony_hours_var),
            ax=ax2,
            x='generation',
            y='hours_since_birth',
            palette='rocket',
        )
        sns.stripplot(
            data=self.filter_invalid(colony_hours_var),
            ax=ax2,
            x='generation',
            y='hours_since_birth',
            alpha=0.5,
            color='0.5',
        )
        sns.violinplot(
            data=self.filter_invalid(colony_hours_cv),
            ax=ax3,
            x='generation',
            y='hours_since_birth',
            palette='rocket',
        )
        sns.stripplot(
            data=self.filter_invalid(colony_hours_cv),
            ax=ax3,
            x='generation',
            y='hours_since_birth',
            alpha=0.5,
            color='0.5',
        )
        ax1.set_title('Hours since birth (mean)')
        ax2.set_title('Hours since birth (var)')
        ax3.set_title('Hours since birth (CV)')
        plt.show()

    @staticmethod
    def filter_invalid(df: pd.DataFrame) -> pd.DataFrame:
        """Returns the DataFrame after filtering its rows for NaN, inf, and -inf values."""
        # source: https://stackoverflow.com/questions/45745085
        return df[~df.isin([np.nan, np.inf, -np.inf]).any(1)]  # noqa

    def write_video_colony_signal_vs_size_over_time(self) -> None:
        """Writes a video with the mean Signal in Colonies vs Colony sizes, across all simulation timepoints."""
        fig, ax = plt.subplots(figsize=(8, 8))
        days_groups = [group_data for _, group_data in self.cell_data.groupby('simulation_days')]
        n_days = len(days_groups)
        previous_xs = []
        previous_ys = []

        def update(i: int) -> None:
            """Updates the Figure."""
            self.quiet_print(f'Processing frame: {i+1}/{n_days}')
            ax.clear()
            ax.scatter(previous_xs, previous_ys, color='gray', alpha=0.3, s=2)
            current_data = days_groups[i]
            current_xs = current_data.groupby('colony_name').count().iloc[:, 0]
            current_ys = current_data.groupby('colony_name')['signal_value'].var()
            ax.scatter(current_xs, current_ys, color='blue', s=10)
            previous_xs.extend(current_xs.values)
            previous_ys.extend(current_ys.values)
            ax.set_xlabel('Colony Size')
            ax.set_ylabel('Signal Variance in Colony')
            ax.set_title(f'Simulation time: {round(current_data["simulation_hours"].values[0], 2)}h')
            ax.set_xticks([tick for tick in ax.get_xticks() if tick.is_integer()])
            fig.tight_layout()

        ani = FuncAnimation(fig, update, frames=n_days, interval=1000/6)
        ani.save(self.path / 'signal_dynamics.mp4')

    def write_video_colony_fitness_over_time(self) -> None:
        """Writes a video with the fitness distribution in Colonies, across all simulation timepoints."""
        fig, ax = plt.subplots(figsize=(8, 8))
        days_groups = [group_data for _, group_data in self.cell_data.groupby('simulation_days')]
        n_days = len(days_groups)

        def update(i: int) -> None:
            """Updates the Figure."""
            self.quiet_print(f'Processing frame: {i + 1}/{n_days}')
            ax.clear()
            current_data = days_groups[i]
            division_thresholds = current_data.groupby('colony_name')['division_threshold'].mean().values
            death_thresholds = current_data.groupby('colony_name')['death_threshold'].mean().values
            sns.kdeplot(division_thresholds, ax=ax, color='#50983e', label='Division threshold', alpha=0.7)
            sns.rugplot(division_thresholds, ax=ax, color='#50983e')
            sns.kdeplot(death_thresholds, ax=ax, color='#983e50', label='Death threshold', alpha=0.7)
            sns.rugplot(death_thresholds, ax=ax, color='#983e50')
            ax.set_xlabel('Average fitness distribution in colonies')
            ax.set_ylabel('Density')
            ax.set_title(f'Simulation time: {round(current_data["simulation_hours"].values[0], 2)}h')
            ax.set_xlim(-0.05, 1.05)
            ax.set_xticks([0.00, 0.25, 0.50, 0.75, 1.00])
            fig.tight_layout()

        ani = FuncAnimation(fig, update, frames=n_days, interval=1000 / 6)
        ani.save(self.path / 'fitness_dynamics.mp4')
