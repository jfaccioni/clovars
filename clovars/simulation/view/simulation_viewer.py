from __future__ import annotations

from typing import Any, Generator, TYPE_CHECKING

from clovars.abstract import CellNode
from clovars.utils import PathCreatorMixin, QuietPrinterMixin
from clovars.simulation import TreatmentDrawer, TreeDrawer2D, TreeDrawer3D

if TYPE_CHECKING:
    import pandas as pd
    from clovars.bio import Treatment


class SimulationViewer(QuietPrinterMixin, PathCreatorMixin):
    """Class that handles visualization of data generated by a Simulation run."""
    default_colormap_name = 'viridis'
    default_dpi = 120
    default_layout = 'family'
    default_2D_file_name = '2D'
    default_2D_file_extension = 'png'
    default_video_file_name = 'colony'
    default_video_file_extension = 'mp4'
    default_3D_file_name = '3D'
    default_3D_file_extension = 'png'
    default_treatments_file_name = 'treatments'
    default_treatments_file_extension = 'png'

    def __init__(
            self,
            cell_data: pd.DataFrame,
            well_radius: float,
            treatment_data: dict[tuple[str, int], Treatment],
            output_folder: str = '.',
            verbose: bool = False,
    ) -> None:
        """Initializes a SimulationViewer instance."""
        self.cell_data = cell_data
        self.well_radius = well_radius
        self.treatment_data = treatment_data
        super().__init__(folder=output_folder, verbose=verbose)
        self._well_node = None
        self._roots = None

    def generate_output(
            self,
            settings: dict[str, Any],
    ) -> None:
        """Produces output depending on the values inside the settings dictionary."""
        # TREE SETTINGS
        tree_drawer_settings = {
            'colormap_name': settings.get('colormap_name', self.default_colormap_name),
            'layout': settings.get('layout', self.default_layout),
            'signal_values': self.cell_data['signal_value'],
            'time_values': self.cell_data['simulation_hours'],
            'age_values': self.cell_data['seconds_since_birth'] / 3600,  # in hours
            'generation_values': self.cell_data['generation'],
        }

        # 2D TREES
        tree_drawer_2D = TreeDrawer2D(**tree_drawer_settings, verbose=self.verbose)
        if settings.get('display_2D', False) is True:
            self.quiet_print('Displaying Cell Trees as a 2D plot...')
            tree_drawer_2D.display_trees(root_nodes=self.roots)
        if settings.get('render_2D', False) is True:
            self.quiet_print('Rendering Cell Trees as a 2D plot...')
            tree_drawer_2D.render_trees(
                root_nodes=self.roots,
                folder_path=self.path,
                file_name=settings.get('file_name_2D', self.default_2D_file_name),
                file_extension=settings.get('file_extension_2D', self.default_2D_file_extension),
            )
        if settings.get('render_video_2D', False) is True:
            self.quiet_print('Rendering Cell Trees as a video...')
            tree_drawer_2D.render_tree_videos(
                root_nodes=self.roots,
                folder_path=self.path,
                file_name=settings.get('file_name_video_2D', self.default_video_file_name),
                file_extension=settings.get('file_extension_video_2D', self.default_video_file_extension),
            )

        # 3D TREES
        tree_drawer_3D = TreeDrawer3D(**tree_drawer_settings)
        if settings.get('display_3D', False) is True:
            self.quiet_print('Displaying Cell Trees as a 3D plot...')
            tree_drawer_3D.display_trees(
                root_nodes=self.roots,
                display_well=settings.get('display_well', False),
                z_axis_ratio=settings.get('z_axis_ratio', 1.0),
                well_radius=self.well_radius,
            )
        if settings.get('render_3D', False) is True:
            self.quiet_print('Rendering Cell Trees as a 3D plot...')
            tree_drawer_3D.render_trees(
                root_nodes=self.roots,
                display_well=settings.get('display_well', False),
                z_axis_ratio=settings.get('z_axis_ratio', 1.0),
                well_radius=self.well_radius,
                folder_path=self.path,
                file_name=settings.get('file_name_3D', self.default_3D_file_name),
                file_extension=settings.get('file_extension_3D', self.default_3D_file_extension),
            )

        # TREATMENTS
        treatment_drawer = TreatmentDrawer(treatment_data=self.treatment_data)
        show_division = settings.get('show_division', True)
        show_death = settings.get('show_death', True)
        if settings.get('display_treatments', False) is True:
            self.quiet_print('Displaying the treatment division and death curves...')
            treatment_drawer.display(
                show_division=show_division,
                show_death=show_death,
            )
        if settings.get('render_treatments', False) is True:
            self.quiet_print('Rendering the treatment division and death curves...')
            treatment_drawer.render(
                show_division=show_division,
                show_death=show_death,
                folder_path=self.path,
                file_name=settings.get('file_name_treatments', self.default_treatments_file_name),
                file_extension=settings.get('file_extension_treatments', self.default_treatments_file_extension),
            )

    @property
    def well_node(self) -> CellNode:
        """Returns a CellNode from which all CellNodes grow. Cached as a private attribute."""
        if self._well_node is None:
            self._well_node = self.get_well_node()
        return self._well_node

    @property
    def roots(self) -> list[CellNode]:
        """Returns a list of the root CellNodes. Cached as a private attribute."""
        if self._roots is None:
            self._roots = list(self.yield_roots())
        return self._roots

    def get_well_node(self) -> CellNode:
        """Builds the WellNode and returns it."""
        well_node = CellNode()
        for root in self.roots:
            well_node.add_child(root)  # noqa
        return well_node

    def yield_roots(self) -> Generator[CellNode, None, None]:
        """Returns the root CellNodes of each tree, parsed from the cell_data DataFrame."""
        for root_name, root_data in self.cell_data.groupby('branch_name', sort=False):
            root_node = self.get_root_data(root_name=root_name, root_data=root_data)  # noqa
            yield root_node

    def get_root_data(
            self,
            root_name: str,
            root_data: pd.DataFrame,
    ) -> CellNode:
        """
        Builds the entire CellNode tree of a given colony name and returns its root Node.
        Raises ValueError if the given root_name is not present in the DataFrame.
        """
        if root_name not in root_data['name'].values:
            raise ValueError(f'Root name {root_name} not present in the "Name" column!')
        groups = root_data.sort_values(by=['simulation_seconds']).groupby('name')
        root_node = self.build_tree(root_name=root_name, groups=groups)
        return root_node

    def build_tree(
            self,
            root_name: str,
            groups: pd.DataFrameGroupBy,
            node: CellNode | None = None,
    ) -> CellNode:
        """Recursively builds the CellNode tree from the groups DataFrameGroupBy."""
        try:
            data = groups.get_group(root_name)
        except KeyError:  # Stop condition
            return node
        current_node = node
        for i, data in data.iterrows():
            next_node = CellNode(name=root_name)
            next_node.add_features(**data.to_dict())
            try:
                current_node.add_child(next_node)  # noqa
            except AttributeError:  # current_node is None
                node = next_node  # next_node is actually the root Node
            current_node = next_node
        self.build_tree(root_name=root_name + '.1', groups=groups, node=current_node)
        self.build_tree(root_name=root_name + '.2', groups=groups, node=current_node)
        return node
